package ParserLexer;
import java_cup.runtime.*;
import java.util.ArrayList;
import java.util.HashMap;

action code {: :};

parser code {:
    BasicLexerCupV lex;

    @SuppressWarnings("deprecation")
    public parser(BasicLexerCupV lex) {
        this.lex = lex;
        this.symbolFactory = new DefaultSymbolFactory();
        this.currentHash = null;
    }

    // Tabla de símbolos
    HashMap<String, ArrayList<String>> listaTablasSimbolos = new HashMap<>();
    String currentHash;

    public void imprimirTablaSimbolos() {
        for (String key : listaTablasSimbolos.keySet()) {
            System.out.println("\nTabla de símbolos: " + key);
            System.out.println("+--------+---------+----------------------+------------+");
            System.out.println("| Línea  | Columna | Lexema              | Tipo       |");
            System.out.println("+--------+---------+----------------------+------------+");
            for (String simbolo : listaTablasSimbolos.get(key)) {
                System.out.println(simbolo);
            }
            System.out.println("+--------+---------+----------------------+------------+\n");
        }
    }

    public void agregarTablaSimbolos(String tipoTabla, String nombre) {
        System.out.println("/+++Nueva tabla símbolos función o main+++/ " + nombre);
        ArrayList<String> nuevaTabla = new ArrayList<>();
        currentHash = nombre;
        listaTablasSimbolos.put(currentHash, nuevaTabla);
    }

    public void agregarVariable(int linea, int columna, String lexema, String tipo) {
        System.out.println("PARSER: identificador (agregar o verificar) " + lexema);
        if (currentHash == null) {
            System.err.println("Error: No hay una tabla de símbolos activa");
            return;
        }
        ArrayList<String> tabla = listaTablasSimbolos.get(currentHash);
        if (tabla == null) {
            System.err.println("Error: La tabla de símbolos '" + currentHash + "' no existe");
            return;
        }
        String entrada = String.format("| %-6d | %-7d | %-20s | %-10s |",
                linea + 1, columna + 1, lexema, tipo);
        tabla.add(entrada);
    }
:}

init with {: :};

scan with {: return lex.next_token(); :};

/* Terminales */
terminal corcheteIzquierdo, corcheteDerecho, CORCHETEAPERTURA, CORCHETECIERRE, ASIGNA, PARENTESISAPERTURA, PARENTESISCIERRE, FIN_EXPRESION,
        PRINT, READ, MAIN, COMA;
terminal INTEGER, STRING, CHAR, FLOAT, BOOL, IDENTIFICADOR, TRUE, FALSE;
terminal SUMA, RESTA, DIVISION, MULTIPLICACION, MODULO, POTENCIA, INCREMENTO, DECREMENTO, NEGATIVO;
terminal MENOR, MENOR_IGUAL, MAYOR, MAYOR_IGUAL, IGUAL, DIFERENTE;
terminal CONJUNCION, DISYUNCION, NEGACION;
terminal IF, ELSE, WHILE, FOR, SWITCH, CASE, DEFAULT, BREAK, RETURN, DOS_PUNTOS, PUNTOS;
terminal Integer L_INTEGER;
terminal String L_STRING;
terminal Float L_FLOAT;
terminal Character L_CHAR;

/* No terminales */
non terminal inicio, tipos, expresionRelacional, asignarTipo, operadorRelacional, literales, bool, operadorLogico, negacion,
creacion, creacionAsignacion, sentencias, sentencia, funciones, funcion, bloque, return_estructura,
parametroAux, parametros, tipoArreglo, crearArreglos, modificarArreglos, arreglos, arreglo,
parametrosArregloAux, parametrosArreglo, asignaVariable, variable, operandoBinaria, expresionBinaria,
operandoUnario, expresionUnario, expresionRelacionalMat, expresiones, expresion, sentencia_lista, sentenciaEstructura, if_estructura,
for_estructura, rango, switch_estructura, casos_switch, caso_switch, break_estructura, print, read, encabezadoFuncion, expresionLogica,
while_estructura;

/* Precedencia */
precedence left ELSE;
precedence left MENOR, MENOR_IGUAL, MAYOR, MAYOR_IGUAL;
precedence left IGUAL, DIFERENTE;
precedence left CONJUNCION, DISYUNCION;

/* Producción inicial */
start with inicio;

inicio ::= MAIN
    {: parser.agregarTablaSimbolos("main", "_verano_"); :}
    sentencias
         | funciones
         | error {: System.err.println("Error en la estructura inicial."); :};

/* Definiciones */
tipos ::=INTEGER:i {:RESULT="rodolfo";:}
        | STRING:s {:RESULT="cometa";:}
        | CHAR:c {:RESULT="cupido";:}
        | FLOAT:f {:RESULT="bromista";:}
        | BOOL:b {:RESULT="trueno";:};


literales ::= L_INTEGER:i
              {:
                  Symbol symbol = (Symbol) CUP$parser$stack.peek();
                  parser.agregarVariable(symbol.left, symbol.right, symbol.value.toString(), "rodolfo");
              :}
            | L_STRING:s
              {:
                  Symbol symbol = (Symbol) CUP$parser$stack.peek();
                  parser.agregarVariable(symbol.left, symbol.right, symbol.value.toString(), "cometa");
              :}
            | L_FLOAT:f
              {:
                  Symbol symbol = (Symbol) CUP$parser$stack.peek();
                  parser.agregarVariable(symbol.left, symbol.right, symbol.value.toString(), "bromista");
              :}
            | L_CHAR:c
              {:
                  Symbol symbol = (Symbol) CUP$parser$stack.peek();
                  parser.agregarVariable(symbol.left, symbol.right, symbol.value.toString(), "cupido");
              :}
            | TRUE
              {:
                  Symbol symbol = (Symbol) CUP$parser$stack.peek();
                  parser.agregarVariable(symbol.left, symbol.right, "true", "trueno");
              :}
            | FALSE
              {:
                  Symbol symbol = (Symbol) CUP$parser$stack.peek();
                  parser.agregarVariable(symbol.left, symbol.right, "false", "trueno");
              :};

bool ::= TRUE {:RESULT="true";:}
        | FALSE{:RESULT="false";:};

expresionRelacional ::= asignarTipo operadorRelacional:op literales:l {: System.out.println("Expresión relacional: " + op + " " + l); :}
                     | error {: System.err.println("Error: Expresión relacional inválida"); :};

expresionLogica ::= asignarTipo operadorLogico:op literales:l {: System.out.println("Expresión lógica: " + op + " " + l); :}
                  | negacion literales:n {: System.out.println("Expresión lógica con negación: !" + n); :}
                  | error {: System.err.println("Error: Expresión lógica inválida"); :};

asignarTipo ::= tipos:t IDENTIFICADOR:idVar
    {:
        Symbol symbol = (Symbol) CUP$parser$stack.peek();
        parser.agregarVariable(symbol.left, symbol.right, symbol.value.toString(), t.toString());
    :}
    | tipos error {: System.err.println("Error: Falta identificador después del tipo"); :};

operadorRelacional ::= MENOR {:RESULT="snowball";:}
                       | MENOR_IGUAL {:RESULT="evergreen";:}
                       | MAYOR {:RESULT="minstix";:}
                       | MAYOR_IGUAL {:RESULT="upatree";:}
                       | IGUAL {:RESULT="mary";:}
                       | DIFERENTE {:RESULT="openslae";:};

operadorLogico ::= CONJUNCION {:RESULT="melchor";:}
                   | DISYUNCION {:RESULT="gaspar";:};

negacion ::= NEGACION {:RESULT="baltazar";:};

creacion ::= asignarTipo FIN_EXPRESION;

creacionAsignacion ::= asignarTipo ASIGNA literales FIN_EXPRESION;

sentencias ::= sentencia | sentencias sentencia;
sentencia ::= asignaVariable
            | creacion
            | creacionAsignacion
            | print
            | read
            | break_estructura
            | return_estructura
            | switch_estructura;

funciones ::= funcion
           | funciones funcion;

funcion ::= encabezadoFuncion:e
    {: parser.agregarTablaSimbolos("funcion", e.toString()); :}
    bloque;

encabezadoFuncion ::= tipos:t IDENTIFICADOR:id
    {:
        Symbol symbol = (Symbol) CUP$parser$stack.peek();
        parser.agregarVariable(symbol.left, symbol.right, symbol.value.toString(), t.toString());
        RESULT = id.toString();
    :};

bloque ::= corcheteIzquierdo sentencias corcheteDerecho;

parametros ::= PARENTESISAPERTURA PARENTESISCIERRE
             | PARENTESISAPERTURA parametroAux PARENTESISCIERRE;
parametroAux ::= asignarTipo | parametroAux COMA asignarTipo;

expresionRelacional ::= crearArreglos operadorRelacional arreglos;
expresionLogica ::= crearArreglos operadorLogico arreglos;

tipoArreglo ::= L_CHAR CORCHETEAPERTURA CORCHETECIERRE
              | L_INTEGER CORCHETEAPERTURA CORCHETECIERRE;

crearArreglos ::= tipoArreglo:t IDENTIFICADOR:id
    {:
        Symbol symbol = (Symbol) CUP$parser$stack.peek();
        parser.agregarVariable(symbol.left, symbol.right, symbol.value.toString(), t.toString() + "[]");
    :}
    CORCHETEAPERTURA IDENTIFICADOR CORCHETECIERRE;

modificarArreglos ::= IDENTIFICADOR CORCHETEAPERTURA IDENTIFICADOR CORCHETECIERRE;

arreglos ::= arreglo | arreglos arreglo;
arreglo ::= parametrosArreglo;

parametrosArreglo ::= corcheteIzquierdo corcheteDerecho
                    | corcheteIzquierdo parametrosArregloAux corcheteDerecho;
parametrosArregloAux ::= asignarTipo | parametrosArregloAux COMA asignarTipo;

expresionRelacional ::= asignarTipo operadorRelacional variable;
expresionLogica ::= asignarTipo operadorLogico variable;

asignaVariable ::= variable ASIGNA{:RESULT="entrega";:} literales | modificarArreglos ASIGNA literales;

variable ::= IDENTIFICADOR:idVar {: System.out.println("Variable: " + idVar.toString()); :};

operandoBinaria ::= SUMA {:RESULT="navidad";:}
                | RESTA {:RESULT="intercambio";:}
                | DIVISION {:RESULT="reyes";:}
                | MULTIPLICACION {:RESULT="nochebuena";:}
                | MODULO {:RESULT="magos";:}
                | POTENCIA {:RESULT="adviento";:};

expresionBinaria ::= expresion operandoBinaria expresion;

operandoUnario ::= INCREMENTO {:RESULT="quien";:}
                | DECREMENTO {:RESULT="grinch";:};
expresionUnario ::= expresion operandoUnario | NEGATIVO {:RESULT="-";:} expresion;

expresionRelacionalMat ::= expresion operadorRelacional expresion;

expresiones ::= expresionRelacional
              | expresion
              | operandoBinaria expresion
              | expresionBinaria
              | expresionUnario
              | expresionRelacionalMat
              | PARENTESISAPERTURA expresiones PARENTESISCIERRE;


expresion ::= INTEGER {:RESULT="rodolfo";:}
            | FLOAT {:RESULT="bromista";:};

sentencia_lista ::= sentenciaEstructura | sentencia_lista sentenciaEstructura;

sentenciaEstructura ::= if_estructura
                      | for_estructura
                      | while_estructura
                      | switch_estructura
                      | return_estructura
                      | break_estructura
                      | expresiones FIN_EXPRESION;

if_estructura ::= IF PARENTESISAPERTURA operadorLogico PARENTESISCIERRE sentenciaEstructura
                | IF PARENTESISAPERTURA operadorLogico PARENTESISCIERRE sentenciaEstructura ELSE sentenciaEstructura;

for_estructura ::= FOR PARENTESISAPERTURA IDENTIFICADOR DOS_PUNTOS rango PARENTESISCIERRE sentencia;
while_estructura ::= WHILE PARENTESISAPERTURA expresionLogica PARENTESISCIERRE sentenciaEstructura;

rango ::= expresion PUNTOS expresion
        | expresion PUNTOS expresion PUNTOS;

switch_estructura ::= SWITCH PARENTESISAPERTURA variable:v PARENTESISCIERRE
    {:
        Symbol symbol = (Symbol) CUP$parser$stack.peek();
        parser.agregarVariable(symbol.left, symbol.right, "switch_" + symbol.value.toString(), "switch");
    :}
    corcheteIzquierdo casos_switch corcheteDerecho;

casos_switch ::= caso_switch | casos_switch caso_switch;
caso_switch ::= CASE expresion DOS_PUNTOS sentencia_lista
              | DEFAULT DOS_PUNTOS sentencia_lista;

return_estructura ::= RETURN expresion FIN_EXPRESION
                    | RETURN FIN_EXPRESION;
break_estructura ::= BREAK FIN_EXPRESION;

print ::= PRINT PARENTESISAPERTURA literales PARENTESISCIERRE
        | PRINT PARENTESISAPERTURA variable PARENTESISCIERRE;

read ::= READ PARENTESISAPERTURA expresion PARENTESISCIERRE;