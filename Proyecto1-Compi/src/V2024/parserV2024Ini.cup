package ParserLexer;
import java_cup.runtime.*;
import java.util.ArrayList;
import java.util.HashMap;
import Tree.Arbol;
import Tree.Nodo;

action code {: :};

parser code {:
    BasicLexerCupV lex;

    private int errorCount = 0;

    private Arbol arbol;

    @Override
    public void syntax_error(Symbol s) {
        errorCount++;
        System.err.println("Error sintáctico en línea " + (s.left + 1) +
                           ", columna " + (s.right + 1) + ". Token inesperado: " + s.value);
    }

    // Método para verificar si hubo errores
    public boolean hasErrors() {
        return errorCount > 0;
    }

    @SuppressWarnings("deprecation")
    public parser(BasicLexerCupV lex) {
        this.lex = lex;
        this.symbolFactory = new DefaultSymbolFactory();
        this.currentHash = null;
        this.arbol = new Arbol();
    }

    // Tabla de símbolos
    HashMap<String, ArrayList<String>> listaTablasSimbolos = new HashMap<>();
    String currentHash;

    public void imprimirTablaSimbolos() {
        for (String key : listaTablasSimbolos.keySet()) {
            System.out.println("\nTabla de símbolos: " + key);
            System.out.println("+--------+---------+----------------------+------------+");
            System.out.println("| Línea  | Columna | Lexema              | Tipo       |");
            System.out.println("+--------+---------+----------------------+------------+");
            for (String simbolo : listaTablasSimbolos.get(key)) {
                System.out.println(simbolo);
            }
            System.out.println("+--------+---------+----------------------+------------+\n");
        }
    }

    public void agregarTablaSimbolos(String tipoTabla, String nombre) {
        System.out.println("/+++Nueva tabla símbolos función o main+++/ " + nombre);
        ArrayList<String> nuevaTabla = new ArrayList<>();
        currentHash = nombre;
        listaTablasSimbolos.put(currentHash, nuevaTabla);
    }

    public void agregarVariable(int linea, int columna, String lexema, String tipo) {
        System.out.println("PARSER: identificador (agregar o verificar) " + lexema);
        if (currentHash == null) {
            System.err.println("Error: No hay una tabla de símbolos activa");
            return;
        }
        ArrayList<String> tabla = listaTablasSimbolos.get(currentHash);
        if (tabla == null) {
            System.err.println("Error: La tabla de símbolos '" + currentHash + "' no existe");
            return;
        }
        String entrada = String.format("| %-6d | %-7d | %-20s | %-10s |",
                linea + 1, columna + 1, lexema, tipo);
        tabla.add(entrada);
    }

    public Arbol getArbol() {
        return arbol;
    }

    private Nodo crearNodo(String dato) {
        return new Nodo(dato);
    }
:}

init with {: :};

scan with {: return lex.next_token(); :};

/* Terminales */
terminal corcheteIzquierdo, corcheteDerecho, CORCHETEAPERTURA, CORCHETECIERRE, ASIGNA, PARENTESISAPERTURA, PARENTESISCIERRE, FIN_EXPRESION,
        PRINT, READ, MAIN, COMA;
terminal INTEGER, STRING, CHAR, FLOAT, BOOL, IDENTIFICADOR, TRUE, FALSE;
terminal SUMA, RESTA, DIVISION, MULTIPLICACION, MODULO, POTENCIA, INCREMENTO, DECREMENTO, NEGATIVO;
terminal MENOR, MENOR_IGUAL, MAYOR, MAYOR_IGUAL, IGUAL, DIFERENTE;
terminal CONJUNCION, DISYUNCION, NEGACION;
terminal IF, ELSE, WHILE, FOR, SWITCH, CASE, DEFAULT, BREAK, RETURN, DOS_PUNTOS;
terminal Integer L_INTEGER;
terminal String L_STRING;
terminal Float L_FLOAT;
terminal Character L_CHAR;

/* No terminales */
non terminal inicio, tipos, expresionRelacional, asignarTipo, operadorRelacional, literales, bool, operadorLogico, negacion,
creacion, creacionAsignacion, sentencias, sentencia, funciones, funcion, bloque, return_estructura,
parametroAux, parametros, crearArreglos, modificarArreglos, arreglos, arreglo,
parametrosArregloAux, parametrosArreglo, asignaVariable, variable, operandoBinaria, expresionBinaria,
operandoUnario, expresionUnario, expresionRelacionalMat, expresiones, sentencia_lista, sentenciaEstructura, if_estructura,
for_estructura, switch_estructura, casos_switch, caso_switch, break_estructura, print, read, encabezadoFuncion, expresionLogica,
while_estructura, return_funcion, tiposArr, expresionArr, default_case,numerosLiterales, expresionCompleja,numeroEntero,  numeroFloat;

/* Precedencia */
precedence left ELSE;
precedence left MENOR, MENOR_IGUAL, MAYOR, MAYOR_IGUAL;
precedence left IGUAL, DIFERENTE;
precedence left CONJUNCION, DISYUNCION;
precedence left SUMA, RESTA;
precedence left MULTIPLICACION, DIVISION, MODULO;
precedence right POTENCIA;
precedence right NEGACION;
precedence left L_INTEGER, L_FLOAT;



/* Producción inicial */
start with inicio;


inicio ::= MAIN:m
    {:
        parser.agregarTablaSimbolos("main", "_verano_");
        Nodo mainNode = new Nodo("_verano_");
        parser.getArbol().setRaiz(mainNode);
        RESULT = mainNode;
    :}
    funciones
    | error {:
             System.err.println("Error en la estructura inicial.");
         :};


/* Definiciones */
tipos ::=INTEGER {:RESULT="rodolfo";:}
        | STRING {:RESULT="cometa";:}
        | CHAR {:RESULT="cupido";:}
        | FLOAT {:RESULT="bromista";:}
        | BOOL {:RESULT="trueno";:};

tiposArr ::=L_INTEGER:i
                          {:
                              Symbol symbol = (Symbol) CUP$parser$stack.peek();
                              parser.agregarVariable(symbol.left, symbol.right, symbol.value.toString(), "rodolfo");
                          :}
        | L_CHAR:c
                        {:
                            Symbol symbol = (Symbol) CUP$parser$stack.peek();
                            parser.agregarVariable(symbol.left, symbol.right, symbol.value.toString(), "cupido");
                        :};

literales ::=
            L_STRING:s
              {:
                  Symbol symbol = (Symbol) CUP$parser$stack.peek();
                  parser.agregarVariable(symbol.left, symbol.right, symbol.value.toString(), "cometa");
              :}
            | L_CHAR:c
              {:
                  Symbol symbol = (Symbol) CUP$parser$stack.peek();
                  parser.agregarVariable(symbol.left, symbol.right, symbol.value.toString(), "cupido");
              :}
            | bool
            | numerosLiterales;
numerosLiterales ::=
    numeroEntero
    | numeroFloat;

numeroEntero ::= L_INTEGER
    {:
        Symbol symbol = (Symbol) CUP$parser$stack.peek();
        parser.agregarVariable(symbol.left, symbol.right, symbol.value.toString(), "rodolfo");
    :};

numeroFloat ::= L_FLOAT
    {:
        Symbol symbol = (Symbol) CUP$parser$stack.peek();
        parser.agregarVariable(symbol.left, symbol.right, symbol.value.toString(), "bromista");
    :};


bool ::= TRUE {:RESULT="true";:}
        | FALSE{:RESULT="false";:};

expresionRelacional ::= asignarTipo operadorRelacional:op literales:l {: System.out.println("Expresión relacional: " + op + " " + l); :}
                     | asignarTipo operadorRelacional variable
                     | operadorRelacional literales;

expresionLogica ::= asignarTipo operadorLogico:op literales:l {: System.out.println("Expresión lógica: " + op + " " + l); :}
                  | negacion literales:n {: System.out.println("Expresión lógica con negación: !" + n); :}
                  |  asignarTipo operadorLogico variable;

asignarTipo ::= tipos:t IDENTIFICADOR:idVar
    {:
        if (t == null || idVar == null) {
            System.err.println("Error: Tipo o identificador no definido.");
            parser.agregarVariable(0, 0, "undefined", "undefined");
        } else {
            Symbol symbol = (Symbol) CUP$parser$stack.peek();
            parser.agregarVariable(symbol.left, symbol.right, idVar.toString(), t.toString());
        }
    :};


operadorRelacional ::= MENOR {:RESULT="snowball";:}
                       | MENOR_IGUAL {:RESULT="evergreen";:}
                       | MAYOR {:RESULT="minstix";:}
                       | MAYOR_IGUAL {:RESULT="upatree";:}
                       | IGUAL {:RESULT="mary";:}
                       | DIFERENTE {:RESULT="openslae";:};

operadorLogico ::= CONJUNCION {:RESULT="melchor";:}
                   | DISYUNCION {:RESULT="gaspar";:};

negacion ::= NEGACION {:RESULT="baltazar";:};

creacion ::= asignarTipo FIN_EXPRESION
           | error {: System.err.println("Error: Asignación inválida"); :};

creacionAsignacion ::=
            //asignarTipo ASIGNA literales FIN_EXPRESION
             asignarTipo ASIGNA expresiones FIN_EXPRESION
            | asignarTipo ASIGNA expresionLogica FIN_EXPRESION
            | asignarTipo ASIGNA IDENTIFICADOR FIN_EXPRESION
            | asignarTipo error {: System.err.println("Error: Expresión inválida"); :}
            | ASIGNA literales FIN_EXPRESION
             error {: System.err.println("Error: Falta la asignación"); :}
            | asignarTipo ASIGNA literales
            error {: System.err.println("Error: Falta el fin de expresión"); :};

sentencias ::= sentencia | sentencias sentencia;
sentencia ::=
            expresionArr
            | sentenciaEstructura
            | asignaVariable
            | creacion
            | creacionAsignacion
            | print
            | read;

funciones ::= funcion
           | funciones funcion;

funcion ::= encabezadoFuncion:e
    {: parser.agregarTablaSimbolos("funcion", e.toString()); :}
    parametros
    bloque
    ;

encabezadoFuncion ::= tipos:t IDENTIFICADOR:id
    {:
        Symbol symbol = (Symbol) CUP$parser$stack.peek();
        parser.agregarVariable(symbol.left, symbol.right, symbol.value.toString(), t.toString());
        RESULT = id.toString();
    :}
     | IDENTIFICADOR
      error {: System.err.println("Error: Al encabezado de la función le falta el tipo"); :}
     |error;

bloque ::= corcheteIzquierdo sentencias return_funcion corcheteDerecho
//         | corcheteIzquierdo sentenciaEstructura return_funcion corcheteDerecho
//         | corcheteIzquierdo expresionArr return_funcion corcheteDerecho
         | corcheteIzquierdo  corcheteDerecho
         error {: System.err.println("Error: bloque vacio"); :}
         | corcheteIzquierdo sentencias  corcheteDerecho
            error {: System.err.println("Error: A la función le falta el retorno"); :};

return_funcion ::= RETURN literales:t FIN_EXPRESION
    {:
        if (t == null) {
            System.err.println("Error: El tipo de retorno es nulo.");
            parser.agregarVariable(0, 0, "return", "undefined");
        } else {
            Symbol symbol = (Symbol) CUP$parser$stack.peek();
            parser.agregarVariable(symbol.left, symbol.right, "return", t.toString());
        }
    :}
    | RETURN variable:v FIN_EXPRESION
    {:
        if (v == null) {
            System.err.println("Error: El valor de retorno es nulo.");
            parser.agregarVariable(0, 0, "return", "undefined");
        } else {
            Symbol symbol = (Symbol) CUP$parser$stack.peek();
            parser.agregarVariable(symbol.left, symbol.right, "return", v.toString());
        }
    :};



parametros ::= PARENTESISAPERTURA{: RESULT = "abreregalo"; :}
                PARENTESISCIERRE{: RESULT = "cierraregalo"; :}
             | PARENTESISAPERTURA{: RESULT = "abreregalo"; :}
              parametroAux PARENTESISCIERRE{: RESULT = "cierraregalo"; :}
              | error {: System.err.println("Error: Parametros mal definidos"); :};

parametroAux ::= tipos:t IDENTIFICADOR:id
    {:
        if (t == null || id == null) {
            System.err.println("Error: Parámetro inválido (tipo o identificador nulo).");
            parser.agregarVariable(0, 0, "parametro: undefined", "undefined");
        } else {
            Symbol symbol = (Symbol) CUP$parser$stack.peek();
            parser.agregarVariable(symbol.left, symbol.right, "parametro: " + id.toString(), t.toString());
            System.out.println("Parámetro agregado: " + id.toString() + " de tipo " + t.toString());
        }
    :}
    | parametroAux COMA tipos:t IDENTIFICADOR:id
    {:
        if (t == null || id == null) {
            System.err.println("Error: Parámetro adicional inválido (tipo o identificador nulo).");
            parser.agregarVariable(0, 0, "parametro: undefined", "undefined");
        } else {
            Symbol symbol = (Symbol) CUP$parser$stack.peek();
            parser.agregarVariable(symbol.left, symbol.right, "parametro: " + id.toString(), t.toString());
            System.out.println("Parámetro adicional agregado: " + id.toString() + " de tipo " + t.toString());
        }
    :};

expresionArr ::= crearArreglos operadorRelacional arreglos FIN_EXPRESION
                 | crearArreglos ASIGNA arreglos FIN_EXPRESION
                 | arreglos ASIGNA arreglos FIN_EXPRESION
                 | arreglos operadorRelacional arreglos FIN_EXPRESION;
//expresionLogica ::= crearArreglos operadorLogico arreglos;

crearArreglos ::=tipos:t  IDENTIFICADOR:id
                {:
                Symbol symbol = (Symbol) CUP$parser$stack.peek();
                parser.agregarVariable(symbol.left, symbol.right, symbol.value.toString(), t.toString() + "[]");
                :}
                CORCHETEAPERTURA IDENTIFICADOR:idVarArr CORCHETECIERRE;


modificarArreglos ::= IDENTIFICADOR:idVar
                      CORCHETEAPERTURA{: RESULT = "abreempaque"; :}
                      IDENTIFICADOR:id
                      CORCHETECIERRE{: RESULT = "cierraempaque"; :} ;


arreglos ::= arreglo | arreglos arreglo;
arreglo ::= parametrosArreglo;

parametrosArreglo ::= corcheteIzquierdo corcheteDerecho
                    | corcheteIzquierdo parametrosArregloAux corcheteDerecho;

parametrosArregloAux ::= tiposArr | parametrosArregloAux COMA{: RESULT = ","; :}
                                        tiposArr;

//expresionRelacional ::= asignarTipo operadorRelacional variable;
//expresionLogica ::= asignarTipo operadorLogico variable;

asignaVariable ::= variable ASIGNA{:RESULT="entrega";:} literales
                | variable ASIGNA expresionCompleja FIN_EXPRESION
                | modificarArreglos ASIGNA{:RESULT="entrega";:} tiposArr FIN_EXPRESION
                | modificarArreglos operadorRelacional tiposArr FIN_EXPRESION;

variable ::= IDENTIFICADOR:idVar {: System.out.println("Variable: " + idVar.toString()); :};


expresionCompleja ::= expresionBinaria
                    | expresionUnario
                    | expresionRelacionalMat
                    | expresionLogica
                    | PARENTESISAPERTURA expresionCompleja PARENTESISCIERRE
                    | expresionBinaria operadorRelacional expresionLogica
                    | expresionLogica operadorLogico literales
                    | expresionBinaria expresionUnario
                    | expresionCompleja operadorRelacional numerosLiterales operadorLogico bool;


operandoBinaria ::= SUMA {:RESULT="navidad";:}
                | RESTA {:RESULT="intercambio";:}
                | DIVISION {:RESULT="reyes";:}
                | MULTIPLICACION {:RESULT="nochebuena";:}
                | MODULO {:RESULT="magos";:}
                | POTENCIA {:RESULT="adviento";:};

expresionBinaria ::= numerosLiterales operandoBinaria numerosLiterales
                    | numerosLiterales operandoBinaria
                    | variable operandoBinaria numerosLiterales;


operandoUnario ::= INCREMENTO {:RESULT="quien";:}
                | DECREMENTO {:RESULT="grinch";:};
expresionUnario ::= numerosLiterales operandoUnario
                | NEGATIVO {:RESULT="-";:}
                numerosLiterales
                | variable operandoUnario;

expresionRelacionalMat ::= numerosLiterales operadorRelacional numerosLiterales
                       | variable operadorRelacional numerosLiterales
                       | variable operadorRelacional numerosLiterales operandoBinaria numerosLiterales;

expresiones ::= expresionRelacional
              | literales
              | operandoBinaria numerosLiterales
              | expresionBinaria
              | expresionUnario
              | expresionRelacionalMat
              | variable ASIGNA variable
              | PARENTESISAPERTURA {: RESULT = "abreregalo"; :}
              expresiones
              PARENTESISCIERRE{: RESULT = "cierraregalo"; :};


sentencia_lista ::= sentenciaEstructura | sentencia_lista sentenciaEstructura;

sentenciaEstructura ::=  for_estructura
                    | while_estructura
                    | if_estructura
                    | switch_estructura
                    | expresiones FIN_EXPRESION{:RESULT="finregalo";:};


if_estructura ::= IF PARENTESISAPERTURA expresiones PARENTESISCIERRE corcheteIzquierdo sentenciaEstructura corcheteDerecho
                 | IF PARENTESISAPERTURA expresiones PARENTESISCIERRE corcheteIzquierdo return_estructura corcheteDerecho
                 | IF PARENTESISAPERTURA expresiones PARENTESISCIERRE corcheteIzquierdo sentenciaEstructura return_estructura corcheteDerecho
                 | IF PARENTESISAPERTURA expresiones PARENTESISCIERRE corcheteIzquierdo expresiones corcheteDerecho
                 | if_estructura
                 ELSE corcheteIzquierdo sentenciaEstructura corcheteDerecho
                 | if_estructura
                  ELSE corcheteIzquierdo return_estructura corcheteDerecho
                 | if_estructura
                 ELSE corcheteIzquierdo sentenciaEstructura return_estructura corcheteDerecho
                 | if_estructura
                 ELSE corcheteIzquierdo expresiones corcheteDerecho;

for_estructura ::= FOR PARENTESISAPERTURA
                    variable ASIGNA literales
                    COMA
                    expresiones
                    COMA
                    expresionUnario
                   PARENTESISCIERRE corcheteIzquierdo sentencia_lista corcheteDerecho
                  | FOR PARENTESISAPERTURA
                  creacionAsignacion COMA
                  expresionLogica COMA
                  expresionUnario
                  PARENTESISCIERRE
                  corcheteIzquierdo sentencias corcheteDerecho
    {:
        System.out.println("Estructura for reconocida.");
    :};


while_estructura ::= WHILE PARENTESISAPERTURA expresionCompleja PARENTESISCIERRE corcheteIzquierdo expresiones corcheteDerecho
                    | WHILE PARENTESISAPERTURA expresionCompleja operadorLogico expresiones expresionRelacional  PARENTESISCIERRE
                    corcheteIzquierdo expresiones return_estructura corcheteDerecho
                    | WHILE PARENTESISAPERTURA expresionCompleja operadorLogico expresiones expresionRelacional  PARENTESISCIERRE
                     corcheteIzquierdo sentencia return_estructura corcheteDerecho
                    | WHILE PARENTESISAPERTURA expresionCompleja operadorLogico expresiones  PARENTESISCIERRE
                    corcheteIzquierdo expresiones return_estructura corcheteDerecho;

switch_estructura ::= SWITCH PARENTESISAPERTURA variable:v PARENTESISCIERRE
                     corcheteIzquierdo casos_switch corcheteDerecho
                     |SWITCH PARENTESISAPERTURA variable:v PARENTESISCIERRE
                     corcheteIzquierdo casos_switch default_case corcheteDerecho
                     | SWITCH PARENTESISAPERTURA variable:v PARENTESISCIERRE
                     corcheteIzquierdo casos_switch return_estructura corcheteDerecho
                     | SWITCH PARENTESISAPERTURA variable:v PARENTESISCIERRE
                     corcheteIzquierdo casos_switch return_estructura default_case corcheteDerecho
                     | SWITCH PARENTESISAPERTURA variable:v PARENTESISCIERRE
                      corcheteIzquierdo casos_switch break_estructura corcheteDerecho
                     | SWITCH PARENTESISAPERTURA variable:v PARENTESISCIERRE
                     corcheteIzquierdo casos_switch break_estructura default_case corcheteDerecho;

casos_switch ::= caso_switch
               | casos_switch caso_switch
               | break_estructura;

caso_switch ::= CASE numerosLiterales DOS_PUNTOS sentencia_lista FIN_EXPRESION
     {:
     System.out.println("Caso switch reconocido.");
     :}
     | CASE numerosLiterales DOS_PUNTOS expresiones FIN_EXPRESION;

default_case ::= DEFAULT DOS_PUNTOS expresiones FIN_EXPRESION
     {:
         System.out.println("Caso default reconocido.");
    :};

return_estructura ::= RETURN numerosLiterales FIN_EXPRESION
                    | RETURN FIN_EXPRESION;

break_estructura ::= BREAK FIN_EXPRESION;

print ::= PRINT PARENTESISAPERTURA literales PARENTESISCIERRE FIN_EXPRESION
        | PRINT PARENTESISAPERTURA variable PARENTESISCIERRE FIN_EXPRESION
        | PRINT PARENTESISAPERTURA variable
        error {: System.err.println("Error: No se cerró el print"); :}
        | PRINT
        error {: System.err.println("Error: Print mal formado"); :}
        | PRINT  variable  PARENTESISCIERRE
                  error {: System.err.println("Print mal formado"); :};

read ::= READ PARENTESISAPERTURA numerosLiterales PARENTESISCIERRE FIN_EXPRESION
        |  READ PARENTESISAPERTURA variable PARENTESISCIERRE FIN_EXPRESION
        | READ PARENTESISAPERTURA  PARENTESISCIERRE
        error ;