package ParserLexer;
import java_cup.runtime.*;


//utiliza class BasicLexerCupV que genera el lexer.jflex, pequeños cambios de lo tomado de la página de cup
//cambios en parser code, init with y scan with {:

action code {:
     // Método para reportar errores
     void reportError(String message, Symbol sym) {
         System.err.println("Error: " + message + " en línea " + (sym.left + 1) + ", columna " + (sym.right + 1));
     }

     void reportGenericError(String message) {
         System.err.println("Error: " + message);
     }
:}; //Por ahora se queda vacio

parser code {:
    // Connect this parser to a scanner!
    BasicLexerCupV lex;

    @SuppressWarnings("deprecation")
    public parser(BasicLexerCupV lex){
        this.lex=lex;
        this.symbolFactory = new DefaultSymbolFactory();
    }

    @Override
    public void report_error(String message, Object info) {
        if (info instanceof Symbol) {
            Symbol sym = (Symbol) info;
            System.err.println("Error de análisis: " + message + " en línea " + (sym.left + 1) + ", columna " + (sym.right + 1));
        } else {
            System.err.println("Error de análisis: " + message + " (posición desconocida)");
        }
    }

    @Override
    public void report_fatal_error(String message, Object info) throws Exception {
        report_error(message, info);
        throw new Exception("Error fatal: " + message);
    }
:}

init with {: :};

/* define how to connect to the scanner! */
scan with {: return lex.next_token(); :};

/* Terminales (tokens retornados por el scanner). */
terminal corcheteIzquierdo, corcheteDerecho,  CORCHETEAPERTURA, CORCHETECIERRE, ASIGNA, PARENTESISAPERTURA, PARENTESISCIERRE, FIN_EXPRESION,
        PRINT, READ, MAIN, COMA;
terminal INTEGER, STRING, CHAR, FLOAT,BOOL, IDENTIFICADOR, TRUE, FALSE; /*  tipos de datos e identificador  estos representan la palabra reservada*/
terminal  SUMA,RESTA, DIVISION, MULTIPLICACION, MODULO, POTENCIA, INCREMENTO, DECREMENTO, NEGATIVO; /*  expresiones aritméticas y operadores unarios */
terminal MENOR, MENOR_IGUAL, MAYOR, MAYOR_IGUAL, IGUAL, DIFERENTE; /* expresiones relacionales*/
terminal CONJUNCION, DISYUNCION, NEGACION; /* expresiones lógicas*/
terminal IF, ELSE, WHILE, FOR, SWITCH, CASE, DEFAULT, BREAK, RETURN, DOS_PUNTOS,PUNTOS; /*estructuras de control*/
terminal  L_INTEGER, L_STRING, L_FLOAT, L_CHAR; /*estos representan los tipos de datos en si es decir L_FLOAT es 16.3 por ejemplo y L_STRING es el que permite algo como "hola"*/

// no terminales
non terminal inicio, tipos, expresionRelacional, asignarTipo,  operadorRelacional, literales, bool, operadorLogico, negacion,
creacion,creacionAsignacion, sentencias, sentencia, funciones, funcion, bloque, return_estructura,
parametroAux, parametro, parametros, tipoArreglo,crearArreglos,modificarArreglos, arreglos, arreglo,
parametrosArregloAux, parametrosArreglo, parametrosArreglos, asignaVariable, variable,operandoBinaria,expresionBinaria,
operandoUnario,expresionUnario,expresionRelacionalMat,expresiones,expresion,sentencia_lista,sentenciaEstructura,if_estructura,
for_estructura,rango, switch_estructura,casos_switch,caso_switch, break_estructura, print, read,encabezadoFuncion,expresionLogica,
parametroArreglos;

//produccion de inicio
start with inicio;

inicio ::= MAIN
         | error {:
             reportError("Se esperaba MAIN al inicio del programa", parser.getSymbolFactory().newSymbol("error", 0));
         :};

tipos ::= L_INTEGER | L_STRING | L_FLOAT | L_CHAR | bool;
bool ::= TRUE | FALSE;
literales ::= INTEGER | STRING | CHAR | FLOAT | BOOL;

expresionRelacional ::= asignarTipo operadorRelacional literales
                      | error {:
                          reportError("Expresión relacional inválida", parser.getSymbolFactory().newSymbol("error", 0));
                      :};
expresionLogica ::= asignarTipo operadorLogico literales
                  | asignarTipo operadorLogico literales | negacion literales
                  | error {:
                      reportError("Expresión lógica inválida", parser.getSymbolFactory().newSymbol("error", 0));
                  :};

asignarTipo ::= tipos IDENTIFICADOR
              | error {:
                  reportError("Asignación de tipo inválida", parser.getSymbolFactory().newSymbol("error", 0));
              :};

operadorRelacional ::= MENOR | MENOR_IGUAL | MAYOR | MAYOR_IGUAL | IGUAL | DIFERENTE;
operadorLogico ::= CONJUNCION | DISYUNCION;
negacion ::= NEGACION;

creacion ::= asignarTipo FIN_EXPRESION
           | error {:
               reportError("Creación inválida", parser.getSymbolFactory().newSymbol("error", 0));
           :};
creacionAsignacion ::= asignarTipo ASIGNA literales FIN_EXPRESION
                     | error {:
                         reportError("Asignación inválida", parser.getSymbolFactory().newSymbol("error", 0));
                     :};

sentencias ::= sentencia | sentencias sentencia
             | error {:
                 reportGenericError("Error en las sentencias");
             :};
sentencia ::= creacion | creacionAsignacion
            | error {:
                reportGenericError("Error en una sentencia específica");
            :};

funciones ::= funcion | funciones funcion
            | error {:
                reportGenericError("Error en las funciones");
            :};
funcion ::= encabezadoFuncion bloque
          | error {:
              reportGenericError("Error en la definición de función");
          :};

encabezadoFuncion ::= asignarTipo parametros
                    | error {:
                        reportError("Encabezado de función inválido", parser.getSymbolFactory().newSymbol("error", 0));
                    :};
bloque ::= corcheteIzquierdo sentencias return_estructura corcheteDerecho
         | error {:
             reportGenericError("Bloque inválido");
         :};
bloque ::= corcheteIzquierdo sentencia_lista return_estructura corcheteDerecho;

parametros ::= PARENTESISAPERTURA PARENTESISCIERRE
             | PARENTESISAPERTURA parametroAux PARENTESISCIERRE;
parametroAux ::= parametro | parametroAux COMA parametro;
parametro ::= asignarTipo;

expresionRelacional ::= crearArreglos operadorRelacional arreglos;
expresionLogica ::= crearArreglos operadorLogico arreglos;

tipoArreglo ::= L_INTEGER | L_CHAR;
crearArreglos ::= tipoArreglo IDENTIFICADOR CORCHETEAPERTURA IDENTIFICADOR CORCHETECIERRE;
modificarArreglos ::= IDENTIFICADOR CORCHETEAPERTURA IDENTIFICADOR CORCHETECIERRE;

arreglos ::= arreglo | arreglos arreglo;
arreglo ::= parametrosArreglo;

parametrosArreglo ::= corcheteIzquierdo corcheteDerecho;
parametrosArreglo ::= corcheteIzquierdo parametrosArregloAux corcheteDerecho;
parametrosArregloAux ::= parametroArreglos | parametrosArregloAux COMA parametroArreglos;
parametroArreglos ::= CHAR | INTEGER;

expresionRelacional ::= asignarTipo operadorRelacional variable;
expresionLogica ::= asignarTipo operadorLogico variable;

asignaVariable ::= variable ASIGNA literales;
variable ::= IDENTIFICADOR;

operandoBinaria ::= SUMA | RESTA | DIVISION | MULTIPLICACION | MODULO | POTENCIA;
expresionBinaria ::= expresion operandoBinaria expresion;

operandoUnario ::= INCREMENTO | DECREMENTO;
expresionUnario ::= expresion operandoUnario;

expresionRelacionalMat ::= expresion operadorRelacional expresion;

expresiones ::= PARENTESISAPERTURA expresiones PARENTESISCIERRE | expresionBinaria | expresionUnario | expresionRelacionalMat;
expresiones ::= PARENTESISAPERTURA expresionBinaria PARENTESISCIERRE | PARENTESISAPERTURA expresionRelacionalMat PARENTESISCIERRE;
expresiones ::= expresion | expresiones expresion | operandoBinaria;
expresion ::= INTEGER | FLOAT;

sentencia_lista ::= sentenciaEstructura | sentencia_lista sentencia
                  | error {:
                      reportError("Error en lista de sentencias", parser.getSymbolFactory().newSymbol("error", 0));
                  :};

sentenciaEstructura ::= if_estructura
                      | for_estructura
                      | switch_estructura
                      | return_estructura
                      | break_estructura
                      | expresion FIN_EXPRESION
                      | error {:
                          reportError("Error en sentencia de estructura", parser.getSymbolFactory().newSymbol("error", 0));
                      :};

if_estructura ::= IF PARENTESISAPERTURA operadorLogico PARENTESISCIERRE sentenciaEstructura
                | IF PARENTESISAPERTURA operadorLogico PARENTESISCIERRE sentenciaEstructura ELSE sentenciaEstructura
                | error {:
                    reportError("Error en estructura IF", parser.getSymbolFactory().newSymbol("error", 0));
                :};

for_estructura ::= FOR PARENTESISAPERTURA IDENTIFICADOR DOS_PUNTOS rango PARENTESISCIERRE sentencia;

rango ::= expresion PUNTOS expresion
        | expresion PUNTOS expresion PUNTOS;

switch_estructura ::= SWITCH PARENTESISAPERTURA expresion PARENTESISCIERRE corcheteIzquierdo casos_switch corcheteDerecho;

casos_switch ::= caso_switch
               | casos_switch caso_switch;

caso_switch ::= CASE expresion DOS_PUNTOS sentencia_lista
              | DEFAULT DOS_PUNTOS sentencia_lista;

return_estructura ::= RETURN expresion FIN_EXPRESION
                    | RETURN FIN_EXPRESION
                    | error {:
                        reportError("Estructura de retorno inválida", parser.getSymbolFactory().newSymbol("error", 0));
                    :};
break_estructura ::= BREAK FIN_EXPRESION
                   | error {:
                       reportError("Estructura de break inválida", parser.getSymbolFactory().newSymbol("error", 0));
                   :};

print ::= PRINT PARENTESISAPERTURA literales PARENTESISCIERRE
        | PRINT PARENTESISAPERTURA variable PARENTESISCIERRE
        | error {:
            reportGenericError("Error en print");
        :};

read ::= READ PARENTESISAPERTURA expresion PARENTESISCIERRE
       | error {:
           reportGenericError("Error en read");
       :};

error ::= error
        | {:
            System.err.println("Error no manejado en el parser. Intentando continuar...");
        :};

